---
layout: post
title: RISC-V on tinyFPGA-BX via WSL with nextpnr - Part 3
date: '2019-01-27T17:36:00.000-08:00'
author: gojimmypi
tags:
- tinyFPGA
- yosys
- nextpnr
- WSL
- FPGA
- icestorm
- RISC-V
- RISCV
modified_time: '2019-02-03T20:07:00.124-08:00'
thumbnail: https://1.bp.blogspot.com/-xHNaiG5PGD0/XE5dzIrarXI/AAAAAAAAB0o/GAFuw5bnLAIuZTDa8jIuPv9P1WiqI9v1gCLcBGAs/s72-c/tinyFPGA.PNG
blogger_id: tag:blogger.com,1999:blog-4109066286647243251.post-4441191026543791867
blogger_orig_url: https://gojimmypi.blogspot.com/2019/01/risc-v-on-tinyfpga-bx-via-wsl-with.html
---

After getting the <a href="https://github.com/tinyfpga/TinyFPGA-BX">tinyFPGA</a> working with the <a href="https://github.com/YosysHQ/yosys">yosys</a> / <a href="https://github.com/cseed/arachne-pnr">Arachne-PNR</a> / <a href="http://www.clifford.at/icestorm/">icestorm</a> toolchain as noted in my <a href="https://gojimmypi.blogspot.com/2019/01/risc-v-on-fpga-tinyfpga-via-wsl.html">prior blog</a>, I wanted to try out <a href="https://github.com/YosysHQ/nextpnr">NextPNR</a>&nbsp;(the&nbsp;Arachne-PNR replacement). This turned out to be a bit of a bumpy ride. Yes, I know it's no fun if it is too easy, but I wonder if I'm approaching my maximum fun capacity? (spoiler: no, this is awesome!)<br /><br />TL;DR. WSL Ubuntu 16.04 or later is needed. There's a <a href="https://github.com/YosysHQ/nextpnr/issues/215#issuecomment-457389461">known problem</a> with NextPNR that prohibits the GUI version from compiling. The tinyFPGA has a <a href="http://www.latticesemi.com/-/media/LatticeSemi/Documents/DataSheets/iCE/FPGA-DS-02029-3-5-iCE40-LP-HX-Family-Data-Sheet.ashx?document_id=49312">iCE40LP8K-CM81</a>; two parameters <i>required</i>: <code>--lp8k</code> and <code>--package cm81</code>. The <a href="https://www.latticesemi.com/icestick">iCEstick</a> has a iCE40HX-1k on board.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-xHNaiG5PGD0/XE5dzIrarXI/AAAAAAAAB0o/GAFuw5bnLAIuZTDa8jIuPv9P1WiqI9v1gCLcBGAs/s1600/tinyFPGA.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="219" data-original-width="294" src="https://1.bp.blogspot.com/-xHNaiG5PGD0/XE5dzIrarXI/AAAAAAAAB0o/GAFuw5bnLAIuZTDa8jIuPv9P1WiqI9v1gCLcBGAs/s1600/tinyFPGA.PNG" /></a></div><div class="separator" style="clear: both; text-align: center;"></div><br /><br />First, it seemed that everything I had was the wrong version. apt-get update / upgrade does not really update as much as one might like. So I first updated <a href="https://cmake.org/install/">CMake</a> and Python:<br /><br /><pre><code>cmake --version<br />sudo apt-get remove cmake<br />sudo apt-get install cmake3<br /><br />sudo apt-get remove 'python3.*'<br />sudo apt-get install python3.5-dev<br /><br /></code></pre><br />Next, I encountered a <a href="https://github.com/YosysHQ/nextpnr/issues/129#issuecomment-455707572">boost issue</a>, similar to <a href="https://github.com/YosysHQ/nextpnr/issues/129">nextpnr issue 129 -&nbsp;cmake: "Could NOT find Boost -- Boost version: 1.58.0"</a>. Then I had <a href="https://github.com/YosysHQ/nextpnr/issues/214">this annoying problem where&nbsp;cmake Could NOT find PythonInterp: (even though Python 3.5.2 is installed)</a>. The problem here was simply that I ran CMake before having the proper version of dependencies installed and the error was cached in CMakeCache.txt !! Simply removing (or renaming) the file <a href="https://github.com/YosysHQ/nextpnr/issues/214#issuecomment-455708892">resolved that</a> - however, I then encountered yet another boot problem (<a href="https://github.com/YosysHQ/nextpnr/issues/215">issue 215</a>:&nbsp;CheckSymbolExists.c:(.text+0x16): undefined reference to `pthread_create'). This one turned out to be that I had Ubuntu 14.04 and needed something newer (thanks to <a href="https://github.com/YosysHQ/nextpnr/issues/215#issuecomment-456053526">@daveshah1 for pointing this out</a>) - despite the <a href="http://www.clifford.at/icestorm/">icestorm</a> tools explicitly naming Ubuntu <i>14</i>.04<br /><br />Here's how I upgraded my WSL Ubuntu to the latest version (16.04):<br /><pre><code>sudo ls # pause if copy/paste for password prompt<br />sudo apt-get update --assume-yes<br />sudo apt-get upgrade --assume-yes<br />sudo apt-get install update-manager-core  --assume-yes<br />sudo do-release-upgrade<br />sudo apt-get update<br />sudo apt-get dist-upgrade<br /><br /># doing this wiped out CMake, so I had to reinstall:<br />wget http://www.cmake.org/files/v3.13/cmake-3.13.3.tar.gz<br />tar xf cmake-3.13.3.tar.gz<br />cd cmake-3.13.3<br />./configure<br />make<br />sudo make install<br />cmake --version<br /><br /># pip was also wiped out (despite Python 3.6 being listed for tinyFBGA install, tinyprog is installed with pip, not pip3)<br />sudo apt-get install python3-pip<br />sudo apt-get install python-pip<br /></code></pre>Then install the nextpnr dependencies: <br /><pre><code>sudo apt-get update<br />sudo apt-get upgrade<br />sudo apt-get install libboost-all-dev<br />sudo apt-get install python3-dev<br />sudo apt-get install qt5-default<br />sudo apt-get install clang-format<br /></code></pre>My final, working <code>Makefile</code> for getting the <a href="https://github.com/tinyfpga/TinyFPGA-BX/tree/master/examples/picosoc">picosoc RISC-V example</a> onto the tinyFPGA looks like this:  <br /><pre><code>upload: hardware.bin firmware.bin<br />        tinyprog --com /dev/ttyS8 -p hardware.bin -u firmware.bin<br /><br /><br />hardware.blif: hardware.v spimemio.v simpleuart.v picosoc.v picorv32.v<br />        yosys -ql hardware.log -p 'synth_ice40 -top hardware -blif hardware.blif -json hardware.json ' $^<br /><br />hardware.asc: hardware.pcf hardware.blif<br />        # arachne-pnr -r -d 8k -P cm81 -o hardware.asc -p hardware.pcf hardware.blif<br />        nextpnr-ice40 --lp8k --package cm81 --json hardware.json --pcf hardware.pcf --asc hardware.asc<br /><br />hardware.bin: hardware.asc<br />        icetime -d hx8k -c 12 -mtr hardware.rpt hardware.asc<br />        icepack hardware.asc hardware.bin<br /><br /><br />firmware.elf: sections.lds start.S firmware.c<br />        /opt/riscv32ic/bin/riscv32-unknown-elf-gcc -march=rv32imc -nostartfiles -Wl,-Bstatic,-T,sections.lds,--strip-debu$<br />firmware.bin: firmware.elf<br />        /opt/riscv32ic/bin/riscv32-unknown-elf-objcopy -O binary firmware.elf /dev/stdout &gt; firmware.bin<br /><br /><br />clean:<br />        rm -f firmware.elf firmware.hex firmware.bin firmware.o firmware.map \<br />              hardware.blif hardware.log hardware.asc hardware.rpt hardware.bin<br /></code></pre><br />What versions are installed? <br /><pre><code>lsb_release -a<br />python --version<br />python3.5 --version<br />cmake --version<br />clang --version<br />echo qtf_default $(apt-cache show qt5-default | grep -m1 Version)<br />echo libboost-all-dev $(apt-cache show libboost-all-dev | grep -m1 Version)<br /><br />for pk in build-essential clang bison flex libreadline-dev \<br />          gawk tcl-dev libffi-dev git mercurial graphviz   \<br />          xdot pkg-config python python3 libftdi-dev \<br />          qt5-default python3-dev libboost-dev; \<br />  do echo "$pk" $(apt-cache show "$pk" | grep -m1 Version); done<br /><br />nextpnr-ice40 --version<br />yosys -V<br />/opt/riscv32ic/bin/riscv32-unknown-elf-gcc -v<br />pip --version<br />echo apio [pip]      $(pip  list | grep apio)<br />echo apio [pip3]     $(pip3 list | grep apio)<br />echo tinyprog [pip]  $(pip  list | grep tinyprog)<br />echo tinyprog [pip3] $(pip3 list | grep tinyprog)<br /></code></pre>Once nextpnr is all compiled, then next thing is to run it in GUI mode! So far, I have been unsuccessful here. At first, I tried to use the MingX, in the same way I did for my <a href="https://gojimmypi.blogspot.com/2017/08/openwrt-remote-network-wireshark-packet.html">OpenWRT / Wireshark exercise</a>. Despite working just fine on an older Ubuntu 14.4, this new 16.4 simply refused to play.<br /><br />So instead, I tried <a href="https://x.cygwin.com/">CygWin/X</a> - I fussed with it for quite some time before I eventually found a <a href="https://superuser.com/questions/1180005/cygwin-x-and-windows-subsystem-for-linux">useful hint</a>. First, run <a href="http://cygwin.com/setup-x86_64.exe">Cygwin installer</a>. I selected all of the "X11" and "Xorg" items:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-tJnfcE_PqdA/XE4gxbIc_xI/AAAAAAAABzk/Hh4YVktJmIA9k-CTga87SGzS_jjIF2EoQCLcBGAs/s1600/cygwin%2B-%2Bx11.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="231" data-original-width="759" height="118" src="https://2.bp.blogspot.com/-tJnfcE_PqdA/XE4gxbIc_xI/AAAAAAAABzk/Hh4YVktJmIA9k-CTga87SGzS_jjIF2EoQCLcBGAs/s400/cygwin%2B-%2Bx11.PNG" width="400" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/--bmDFOJ3otM/XE4g0B7-0yI/AAAAAAAABzo/8UTHSiPhh5MetQ0f4a-QHCkw-7y8M-0FACLcBGAs/s1600/cygwin%2B-%2Bxorg.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="212" data-original-width="722" height="116" src="https://2.bp.blogspot.com/--bmDFOJ3otM/XE4g0B7-0yI/AAAAAAAABzo/8UTHSiPhh5MetQ0f4a-QHCkw-7y8M-0FACLcBGAs/s400/cygwin%2B-%2Bxorg.PNG" width="400" /></a></div><br />Next, in WSL: <br /><pre><code>export DISPLAY=:0 # you may wish you put in this your ~/.bashrc<br /></code></pre>The hint I found was that that I needed to start cygwin X-Server like this:  <br /><pre><code>C:\cygwin64\bin\run.exe --quote /usr/bin/bash.exe -l -c "cd; exec /usr/bin/startxwin -- -listen tcp"<br /></code></pre>Specifically adding that <code> -- -listen tcp</code> command-line parameter. I also needed to copy the <code>.Xauthority</code> file from my cygwin home, to my WSL home. (yes, I know this is getting more kludgey with each step): <br /><pre><code>cp /mnt/c/cygwin64/home/gojimmypi/.Xauthority  .Xauthority<br /></code></pre>without doing this, I had an Authorization error like this: <br /><pre><code>$ xclock<br />Authorization required, but no authorization protocol specified<br />Error: Can't open display: :0<br /></code></pre>The xclock test works just fine: no errors. I'm able to get wireshark to run but I do see some warnings.    <br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-WmP4cV0sFv0/XE4jUnjIzOI/AAAAAAAAB0M/b4jrSK2nQLQZ-ppcrv5An3HpB3BH6ongQCLcBGAs/s1600/wireshark%2Bon%2Bcygwin.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="749" data-original-width="842" height="284" src="https://1.bp.blogspot.com/-WmP4cV0sFv0/XE4jUnjIzOI/AAAAAAAAB0M/b4jrSK2nQLQZ-ppcrv5An3HpB3BH6ongQCLcBGAs/s320/wireshark%2Bon%2Bcygwin.PNG" width="320" /></a></div>Sadly, nextpnr will not launch at all:<br /><pre><code>$ nextpnr-ice40 --gui<br />Could not initialize OpenGL for RasterGLSurface, reverting to RasterSurface.<br />Could not initialize GLX<br />Aborted (core dumped)<br /></code></pre>I tried using the <code>export LIBGL_USE_WGL=1</code> as suggested <a href="https://stackoverflow.com/questions/9915353/how-to-use-current-version-of-opengl-in-cygwin">here</a>, but no change in outcome. I tried the <code>glxinfo | grep OpenGL</code>, but didn't have it installed. Next: <br /><pre><code>sudo apt-get install mesa-utils<br />glxinfo | grep OpenGL<br /></code></pre>This resulted in a new error: <code>Error: couldn't find RGB GLX visual or fbconfig</code>. I then tried to install more of the OpenGL stuff as suggested <a href="http://www.codebind.com/linux-tutorials/install-opengl-ubuntu-linux/">here</a>. (no change in results) <br /><pre><code>sudo apt-get install libglu1-mesa-dev freeglut3-dev mesa-common-dev<br /></code></pre>Still no joy. I'm happy to have nextpnr working in command-line mode, and have successfully used it with the RISC-V on the TinyFPGA instead of Arachne-PNR, but I would have really like to have been able to see the GUI.