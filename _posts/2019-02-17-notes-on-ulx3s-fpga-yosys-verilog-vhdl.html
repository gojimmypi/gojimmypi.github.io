---
layout: post
title: 'Notes on ulx3s FPGA: Yosys, Verilog, VHDL, vhdl2vl (Convert VHDL to Verilog)'
date: '2019-02-17T13:46:00.000-08:00'
author: gojimmypi
tags:
- ULX3S
- vhdl2vl
- VHDL
- yosys
- verilog
modified_time: '2019-02-18T09:49:08.744-08:00'
thumbnail: https://2.bp.blogspot.com/-LjddHnu4-ww/XGnOIkxkMwI/AAAAAAAAB9Q/Qmuofl0JFTgwVvvNungkzRSlySz5eESsACLcBGAs/s72-c/Windows%2Bapp%2Bfrom%2BWSL%2BJTAG.PNG
blogger_id: tag:blogger.com,1999:blog-4109066286647243251.post-8427293710689565545
blogger_orig_url: https://gojimmypi.blogspot.com/2019/02/notes-on-ulx3s-fpga-yosys-verilog-vhdl.html
---

I want to better understand my new ULX3S, and I was hoping to use FOSS FPGA tools. Here I document some things I've recently learned:<br /><br />Some key points (from <a href="https://gitter.im/ulx3s/Lobby/archives/2019/02/14">https://gitter.im/ulx3s/Lobby/</a>&nbsp;):<br /><blockquote class="tr_bq"><ul><li><i>the standard JTAG programming stuff only programs FPGA SRAM; So rebooting the board will "recover" it</i>&nbsp;</li></ul></blockquote><blockquote class="tr_bq"><ul><li><i><strike>In general you have to go through a fairly tedious process involving Diamond Deployment Tool to create a SVF file to program flash, and this will be very slow Otherwise, you are just programming SRAM</strike></i> (update: this is no longer the case; see ujprog -j flash file.bit</li></ul>-- @daveshah1</blockquote>and:<br /><blockquote class="tr_bq"><ul><li><i>I guess the ulx3s-passthru bitstream is by default shipped to you, when you have OLED and ESP32 in box then it makes sense to load the board with passthru.</i></li></ul><ul><li><i>Other boards without OLED and/or ESP32 are probably shipped with f32c with FAT filesystem on config flash to run self-test application at power up.</i></li></ul><ul><li><i>You can erase config flash and ESP32 with whatever you want and flash back to "factory default" from my ulx3s-bin repository.</i></li></ul><ul><li><i>passthru is old source and it needs updated makefile like in prjtrellis-dvi. Yes it tries to find diamond.</i></li></ul><ul><li><i>Passthru is very simple and it could be ported done using opensource tools only. I'm using vhd2vl. For most simple vhdl examples it works great.</i></li></ul><ul><li><i>It can't convert if VHDL source is complex/advanced and has functions and packages.</i></li></ul>-- @emard</blockquote>I case you are wondering about that second USB port (the left one, when facing them):<br /><blockquote class="tr_bq"><i>don't touch the second USB port - it's wired directly into FPGA and thus won't even enumerate on the PC as a serial port unless you do some serious coding at FPGA side (see TinyFPGA Bootloader project - it's pretty much all about it) ... instead, use USB1 which is wired through FT231 chip</i> (see info <a href="https://gitter.im/ulx3s/Lobby/archives/2019/02/17">here</a>)<br />-- @reostat&nbsp;</blockquote>My favorite claims / features:<br /><blockquote class="tr_bq"><ul><li><b><i>ULX3S is unbrickable</i></b>.&nbsp;</li></ul>-- @emard </blockquote>and:<br /><blockquote class="tr_bq"><ul><li><i><b>There is no realistic chance of irreparable damage to the ULX3S in any case</b></i></li></ul>-- @daveshah1</blockquote><br />The term "iCEStorm Toolchain" does not mean Yosys, arache-pnr, nextpnr, Trellis; just iCEStorm.<br /><br />Yosys, arache-pnr, nextpnr, Trellis supports only Verilog, not VHDL<br /><br />I have a ULX3S 12K. The <a href="https://github.com/DoctorWkt/ULX3S-Blinky">Blinky from DoctorWkt</a> expects a 45F chip. Even when editing the <a href="https://github.com/DoctorWkt/ULX3S-Blinky/blob/master/Makefile">original Makefile</a> to instead use the <code>--12</code> option, <code>nextpnr-ecp5</code> failed:<br /><pre><code>Yosys 0.8+148 (git sha1 e112d2fb, clang 6.0.0-1ubuntu2 -fPIC -Os)<br />Time spent: 54% 11x read_verilog (0 sec), 9% 6x techmap (0 sec), ...<br />nextpnr-ecp5 --12k --json blinky.json --basecfg ulx3s_empty.config \<br />--lpf ulx3s_v20.lpf \<br />--textcfg ulx3s_out.config<br />unrecognised option '--12k'<br />Makefile:74: recipe for target 'ulx3s_out.config' failed<br />make: * [ulx3s_out.config] Error 255<br /></code></pre>In fact, things were looking pretty bleak, as the nextpnr-ecp5 does not even list the 12F: <br /><pre><code>nextpnr-ecp5 -- Next Generation Place and Route (git sha1 4c73061)<br /><br />General options:<br />  -h [ --help ]             show help<br />  -v [ --verbose ]          verbose output<br />  -q [ --quiet ]            quiet mode, only errors and warnings displayed<br />  -l [ --log ] arg          log file, all log messages are written to this file<br />                            regardless of -q<br />  --debug                   debug output<br />  -f [ --force ]            keep running after errors<br />  --gui                     start gui<br />  --run arg                 python file to execute instead of default flow<br />  --pre-pack arg            python file to run before packing<br />  --pre-place arg           python file to run before placement<br />  --pre-route arg           python file to run before routing<br />  --post-route arg          python file to run after routing<br />  --json arg                JSON design file to ingest<br />  --seed arg                seed value for random number generator<br />  -r [ --randomize-seed ]   randomize seed value for random number generator<br />  --slack_redist_iter arg   number of iterations between slack redistribution<br />  --cstrweight arg          placer weighting for relative constraint<br />                            satisfaction<br />  --pack-only               pack design only without placement or routing<br />  --ignore-loops            ignore combinational loops in timing analysis<br />  -V [ --version ]          show version<br />  --test                    check architecture database integrity<br />  --freq arg                set target frequency for design in MHz<br />  --no-tmdriv               disable timing-driven placement<br />  --save arg                project file to write<br />  --load arg                project file to read<br /><br />Architecture specific options:<br />  --25k                     set device type to LFE5U-25F<br />  --45k                     set device type to LFE5U-45F<br />  --85k                     set device type to LFE5U-85F<br />  --um-25k                  set device type to LFE5UM-25F<br />  --um-45k                  set device type to LFE5UM-45F<br />  --um-85k                  set device type to LFE5UM-85F<br />  --um5g-25k                set device type to LFE5UM5G-25F<br />  --um5g-45k                set device type to LFE5UM5G-45F<br />  --um5g-85k                set device type to LFE5UM5G-85F<br />  --package arg             select device package (defaults to CABGA381)<br />  --speed arg               select device speedgrade (6, 7 or 8)<br />  --basecfg arg             base chip configuration in Trellis text format<br />                            (deprecated)<br />  --override-basecfg arg    base chip configuration in Trellis text format<br />  --textcfg arg             textual configuration in Trellis format to write<br />  --lpf arg                 LPF pin constraint file(s)<br /></code></pre>@daveshah1 to the rescue once again!<br /><blockquote class="tr_bq"><i>pass --25k to nextpnr, remove the basecfg if your nextpnr is yesterday or today's build otherwise point it to a 25k basecfg, and then pass --idcode 0x21111043 to ecppack</i><br />-- @daveshah1 </blockquote><br />I'm not sure I would have ever guessed the <code>25F</code>, and certainly not the <code>--idcode 0x21111043</code> part. I pulled the latest SymbiFlow/prjtrellis and nextpnr now (git sha1 4c73061), cleaned and rebuilt everything with <a href="https://gist.github.com/gojimmypi/ad5f19f77ec8a438f919a2c72571cccb">my new Makefile</a>, and success to build!  <br /><pre><code>[... snip ..]<br />Info: [ 79471,  79958) |<br />Info: [ 79958,  80445) |***<br />Info: [ 80445,  80932) |*<br />Info: [ 80932,  81419) |***<br />Info: [ 81419,  81906) |********<br />337 warnings, 0 errors<br />ecppack ulx3s_out.config ulx3s.bit --idcode 0x21111043<br /></code></pre>Now recall I am doing this all in WSL Ubuntu, so there are no native USB devices - thus I am forced to use the Windows version of ujprog to actually upload the code to the ULX3S board.<br /><br />The amazing thing here - is that <i>Windows applications can be run from within WSL</i>!<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-LjddHnu4-ww/XGnOIkxkMwI/AAAAAAAAB9Q/Qmuofl0JFTgwVvvNungkzRSlySz5eESsACLcBGAs/s1600/Windows%2Bapp%2Bfrom%2BWSL%2BJTAG.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="654" data-original-width="696" height="301" src="https://2.bp.blogspot.com/-LjddHnu4-ww/XGnOIkxkMwI/AAAAAAAAB9Q/Qmuofl0JFTgwVvvNungkzRSlySz5eESsACLcBGAs/s320/Windows%2Bapp%2Bfrom%2BWSL%2BJTAG.PNG" width="320" /></a></div><br />This seems to completely circumvent the "No Native USB Devices" in WSL. For example, here's the same app compiled for linux, not finding the JTAG device:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-e8fPwZ2xwSc/XGnOZ-i3zMI/AAAAAAAAB9Y/QviZrxSyVk4tfh5lGk8l3cLkgManWVGLgCLcBGAs/s1600/No%2BWSL%2BJTAG%2Blinux%2Bapp.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="315" data-original-width="703" height="143" src="https://3.bp.blogspot.com/-e8fPwZ2xwSc/XGnOZ-i3zMI/AAAAAAAAB9Y/QviZrxSyVk4tfh5lGk8l3cLkgManWVGLgCLcBGAs/s320/No%2BWSL%2BJTAG%2Blinux%2Bapp.PNG" width="320" /></a></div><br /><br />I'm using the very latest FTDI code in <a href="https://github.com/gojimmypi/f32c_tools/tree/master/ujprog">my fork of the f32c tools</a> (I created <a href="https://github.com/f32c/tools/pull/9">this PR #9</a>). I still encountered some problems with the syntax of the ujprog. I opened <a href="https://github.com/f32c/tools/issues/10">issue #10</a>, which was promptly closed - regarding the expected operation. Bottom line is this is the syntax that works:   <br /><pre><code>C:\workspace-git\f32c_tools\ujprog&gt;ujprog ulx3s.bit<br />ULX2S / ULX3S JTAG programmer v 3.0.92 (built Feb 13 2019 12:27:20)<br />Using USB cable: ULX3S FPGA 12K v3.0.3<br />Programming: 100%<br />Completed in 18.66 seconds.<br /></code></pre>And I learned a few more things in the <a href="https://github.com/f32c/tools/issues/10#issuecomment-464197029">close comment</a>:<br /><blockquote class="tr_bq"><i>JTAG doesn't work in COM mode, so no wonder that uploading a bitstream can't work that way, especially not when using the -a modifier, which tells the ujprog to send the file as a stream of bytes.</i><br />-- gornjas </blockquote>From <a href="https://gitter.im/ulx3s/Lobby/archives/2019/02/17">gitter</a>:<br /><blockquote class="tr_bq"><i>ujprog note: supported targets are either -j sram or -j flash</i><br />-- @emard</blockquote>So, ya - I get that all this stuff is obvious to the developers &amp; subject matter experts; However, I struggled to learn each of these things when seeing it all for the first time and relatively little documentation. Although there's no README in the <a href="https://github.com/f32c/tools/tree/master/ujprog">f32c/tools/ujprog</a>, I created <a href="https://github.com/gojimmypi/f32c_tools/blob/master/ujprog/README.md">one in my fork</a>&nbsp;that hopefully will help others.<br /><br />As mentioned above: in order to program the ESP32, the FPGA needs to be configured in "Pass-Through" mode. @emard's <a href="https://github.com/emard/ulx3s-passthru">ulx3s-passthru</a> is written in VHDL.<br /><br />There's a tool called&nbsp;vhdl2vl that can convert some VHDL to Verilog. Yosys has a VDHL reader plugin based on <a href="https://github.com/YosysHQ/yosys-plugins/tree/master/vhdl">vhdl2vl</a>.<br /><pre><code>git clone https://github.com/YosysHQ/yosys-plugins.git<br />cd yosys-plugins/vhdl<br />make<br /><br /># mkdir -p /usr/local/share/yosys/plugins<br /># cp vhdl.so /usr/local/share/yosys/plugins/vhdl.so<br />sudo make install<br /></code></pre>then run <code>yosys</code>, and from the <code>yosys&gt;</code> prompt:<br /><pre><code>plugin  -i vhdl<br />plugin  -l<br /></code></pre>This will add a new <code>read_vhdl</code> command to <code>yosys</code>.  <br /><br />There is more documentation on yosys <a href="http://www.clifford.at/yosys/documentation.html">here</a>.<br /><br />If the plugin is listed and working, typing <code>read_vhdl</code> in <code>yosys</code> will show help:<br /><pre><code>1. Executing VHDL frontend.<br /><br />Syntax error in command `read_vhdl':<br /><br />    read_vhdl [options] [filename]<br /><br />Load modules from a VHDL file to the current design.<br /><br />    -dump_ast1<br />        dump abstract syntax tree (before simplification)<br /><br />    -dump_ast2<br />        dump abstract syntax tree (after simplification)<br /><br />    -no_dump_ptr<br />        do not include hex memory addresses in dump (easier to diff dumps)<br /><br />    -dump_vhdl<br />        dump ast as VHDL code (after simplification)<br /><br />    -yydebug<br />        enable parser debug output<br /><br />    -nolatches<br />        usually latches are synthesized into logic loops<br />        this option prohibits this and sets the output to 'x'<br />        in what would be the latches hold condition<br /><br />        this behavior can also be achieved by setting the<br />        'nolatches' attribute on the respective module or<br />        always block.<br /><br />    -nomem2reg<br />        under certain conditions memories are converted to registers<br />        early during simplification to ensure correct handling of<br />        complex corner cases. this option disables this behavior.<br /><br />        this can also be achieved by setting the 'nomem2reg'<br />        attribute on the respective module or register.<br /><br />        This is potentially dangerous. Usually the front-end has good<br />        reasons for converting an array to a list of registers.<br />        Prohibiting this step will likely result in incorrect synthesis<br />        results.<br /><br />    -mem2reg<br />        always convert memories to registers. this can also be<br />        achieved by setting the 'mem2reg' attribute on the respective<br />        module or register.<br /><br />    -nomeminit<br />        do not infer $meminit cells and instead convert initialized<br />        memories to registers directly in the front-end.<br /><br />    -ppdump<br />        dump VHDL code after pre-processor<br /><br />    -nopp<br />        do not run the pre-processor<br /><br />    -nodpi<br />        disable DPI-C support<br /><br />    -lib<br />        only create empty blackbox modules. This implies -DBLACKBOX.<br /><br />    -noopt<br />        don't perform basic optimizations (such as const folding) in the<br />        high-level front-end.<br /><br />    -icells<br />        interpret cell types starting with '$' as internal cell types<br /><br />    -nooverwrite<br />        ignore re-definitions of modules. (the default behavior is to<br />        create an error message if the existing module is not a black box<br />        module, and overwrite the existing module otherwise.)<br /><br />    -overwrite<br />        overwrite existing modules with the same name<br /><br />    -defer<br />        only read the abstract syntax tree and defer actual compilation<br />        to a later 'hierarchy' command. Useful in cases where the default<br />        parameters of modules yield invalid or not synthesizable code.<br /><br />    -noautowire<br />        make the default of `default_nettype be "none" instead of "wire".<br /><br />    -setattr &lt;attribute_name&gt;<br />        set the specified attribute (to the value 1) on all loaded modules<br /><br />    -Dname[=definition]<br />        define the preprocessor symbol 'name' and set its optional value<br />        'definition'<br /><br />    -Idir<br />        add 'dir' to the directories which are used when searching include<br />        files<br /><br />The command 'vhdl_defaults' can be used to register default options for<br />subsequent calls to 'read_vhdl'.<br /><br />Note that the VHDL frontend does a pretty good job of processing valid<br />VHDL input, but has not very good error reporting. It generally is<br />recommended to use a simulator for checking the syntax of the code, rather<br />than to rely on read_vhdl for that.<br /></code></pre>The yosys VHDL plugin reads a VDHL file like this:<br /><pre><code>yosys&gt; read_vhdl ulx3s_v20_passthru_wifi.vhd<br /><br />3. Executing VHDL frontend.<br />Parsing VHDL input from `ulx3s_v20_passthru_wifi.vhd' to AST representation.<br />ERROR: NOT IMPLEMENTED: ulx3s_v20_passthru_wifi.vhd:16 (vhdl_parser.y:1583)<br /></code></pre>There is probably a different message if it was successful.<br /><br />There's also the <a href="https://github.com/ldoolitt/vhd2vl">vhd2vl</a> noted on the <a href="https://github.com/YosysHQ/yosys-plugins/blob/master/vhdl/README">yosys README</a>.  <br /><pre><code>git clone https://github.com/ldoolitt/vhd2vl.git<br />cd vhd2vl/src<br />make<br />./vhd2vl ../../ulx3s-passthru/rtl/ulx3s_v20_passthru_wifi.vhd<br /></code></pre>With a bit of help info: <br /><pre><code>./vhd2vl --help<br />Usage: vhd2vl [--debug] [--quiet] [--std 1995|2001] source_file.vhd &gt; target_file.v<br />   or  vhd2vl [--debug] [--quiet] [--std 1995|2001] source_file.vhd target_file.v<br /></code></pre>That also had limited success: <br /><pre><code><br />// File ../../ulx3s-passthru/rtl/ulx3s_v20_passthru_wifi.vhd translated with vhd2vl v3.0 VHDL to Verilog RTL translator<br />// vhd2vl settings:<br />//  * Verilog Module Declaration Style: 2001<br /><br />// vhd2vl is Free (libre) Software:<br />//   Copyright (C) 2001 Vincenzo Liguori - Ocean Logic Pty Ltd<br />//     http://www.ocean-logic.com<br />//   Modifications Copyright (C) 2006 Mark Gonzales - PMC Sierra Inc<br />//   Modifications (C) 2010 Shankar Giri<br />//   Modifications Copyright (C) 2002-2017 Larry Doolittle<br />//     http://doolittle.icarus.com/~larry/vhd2vl/<br />//   Modifications (C) 2017 Rodrigo A. Melo<br />//<br />//   vhd2vl comes with ABSOLUTELY NO WARRANTY.  Always check the resulting<br />//   Verilog for correctness, ideally with a formal verification tool.<br />//<br />//   You are welcome to redistribute vhd2vl under certain conditions.<br />//   See the license (GPLv2) file included with the source for details.<br /><br />// The result of translation follows.  Its copyright status should be<br />// considered unchanged from the original VHDL.<br /><br />WARNING (line 70): port default initialization ignored.<br />WARNING (line 70): port default initialization ignored.<br />WARNING (line 70): port default initialization ignored.<br />WARNING (line 70): port default initialization ignored.<br />WARNING (line 70): port default initialization ignored.<br />syntax error, unexpected GENERATE at "generate" in line 145.<br /></code></pre><br />So the reality is that I probably won't be converting VHDL to Verilog anytime soon. However, writing my own Verilog passthrough app should be an excellent beginner FPGA to write.